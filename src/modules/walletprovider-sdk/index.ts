// @ts-nocheck
var z = ($, Q) => () => ($ && (Q = $($ = 0)), Q); function L0($, { strict: Q = !0 } = {}) { if (!$) return !1; if (typeof $ !== "string") return !1; return Q ? /^0x[0-9a-fA-F]*$/.test($) : $.startsWith("0x") } var E0 = z(() => { }); function N0($) { if (L0($, { strict: !1 })) return Math.ceil(($.length - 2) / 2); return $.length } var H0 = z(() => { E0() }); var f0; var B0 = z(() => { f0 = "2.11.1" }); var A0; var P0 = z(() => { B0(); A0 = () => `viem@${f0}` }); class P extends Error { constructor($, Q = {}) { super(); Object.defineProperty(this, "details", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "docsPath", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "metaMessages", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "shortMessage", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "ViemError" }), Object.defineProperty(this, "version", { enumerable: !0, configurable: !0, writable: !0, value: A0() }); const J = Q.cause instanceof P ? Q.cause.details : Q.cause?.message ? Q.cause.message : Q.details, q = Q.cause instanceof P ? Q.cause.docsPath || Q.docsPath : Q.docsPath; if (this.message = [$ || "An error occurred.", "", ...Q.metaMessages ? [...Q.metaMessages, ""] : [], ...q ? [`Docs: https://viem.sh${q}${Q.docsSlug ? `#${Q.docsSlug}` : ""}`] : [], ...J ? [`Details: ${J}`] : [], `Version: ${this.version}`].join("\n"), Q.cause) this.cause = Q.cause; this.details = J, this.docsPath = q, this.metaMessages = Q.metaMessages, this.shortMessage = $ } walk($) { return _0(this, $) } } var _0; var X0 = z(() => { P0(); _0 = ($, Q) => { if (Q?.($)) return $; if ($ && typeof $ === "object" && "cause" in $) return _0($.cause, Q); return Q ? null : $ } }); class h extends P { constructor({ size: $, targetSize: Q, type: J }) { super(`${J.charAt(0).toUpperCase()}${J.slice(1).toLowerCase()} size (${$}) exceeds padding size (${Q}).`); Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "SizeExceedsPaddingSizeError" }) } } var S0 = z(() => { X0() }); function r($, { dir: Q, size: J = 32 } = {}) { if (typeof $ === "string") return O8($, { dir: Q, size: J }); return R8($, { dir: Q, size: J }) } function O8($, { dir: Q, size: J = 32 } = {}) { if (J === null) return $; const q = $.replace("0x", ""); if (q.length > J * 2) throw new h({ size: Math.ceil(q.length / 2), targetSize: J, type: "hex" }); return `0x${q[Q === "right" ? "padEnd" : "padStart"](J * 2, "0")}` } function R8($, { dir: Q, size: J = 32 } = {}) { if (J === null) return $; if ($.length > J) throw new h({ size: $.length, targetSize: J, type: "bytes" }); const q = new Uint8Array(J); for (let N = 0; N < J; N++) { const X = Q === "right"; q[X ? N : J - N - 1] = $[X ? N : $.length - N - 1] } return q } var y0 = z(() => { S0() }); class Y0 extends P { constructor({ max: $, min: Q, signed: J, size: q, value: N }) { super(`Number "${N}" is not in safe ${q ? `${q * 8}-bit ${J ? "signed" : "unsigned"} ` : ""}integer range ${$ ? `(${Q} to ${$})` : `(above ${Q})`}`); Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "IntegerOutOfRangeError" }) } } class Z0 extends P { constructor({ givenSize: $, maxSize: Q }) { super(`Size cannot exceed ${Q} bytes. Given size: ${$} bytes.`); Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "SizeOverflowError" }) } } var I0 = z(() => { X0() }); function V0($, { size: Q }) { if (N0($) > Q) throw new Z0({ givenSize: N0($), maxSize: Q }) } var b0 = z(() => { I0(); H0() }); function _($, Q = {}) { if (typeof $ === "number" || typeof $ === "bigint") return v0($, Q); if (typeof $ === "string") return g0($, Q); if (typeof $ === "boolean") return x0($, Q); return T0($, Q) } function x0($, Q = {}) { const J = `0x${Number($)}`; if (typeof Q.size === "number") return V0(J, { size: Q.size }), r(J, { size: Q.size }); return J } function T0($, Q = {}) { let J = ""; for (let N = 0; N < $.length; N++)J += G8[$[N]]; const q = `0x${J}`; if (typeof Q.size === "number") return V0(q, { size: Q.size }), r(q, { dir: "right", size: Q.size }); return q } function v0($, Q = {}) { const { signed: J, size: q } = Q, N = BigInt($); let X; if (q) if (J) X = (1n << BigInt(q) * 8n - 1n) - 1n; else X = 2n ** (BigInt(q) * 8n) - 1n; else if (typeof $ === "number") X = BigInt(Number.MAX_SAFE_INTEGER); const Y = typeof X === "bigint" && J ? -X - 1n : 0; if (X && N > X || N < Y) { const T = typeof $ === "bigint" ? "n" : ""; throw new Y0({ max: X ? `${X}${T}` : void 0, min: `${Y}${T}`, signed: J, size: q, value: `${$}${T}` }) } const Z = `0x${(J && N < 0 ? (1n << BigInt(q * 8)) + BigInt(N) : N).toString(16)}`; if (q) return r(Z, { size: q }); return Z } function g0($, Q = {}) { const J = K8.encode($); return T0(J, Q) } var G8, K8; var c0 = z(() => { I0(); y0(); b0(); G8 = Array.from({ length: 256 }, ($, Q) => Q.toString(16).padStart(2, "0")), K8 = new TextEncoder }); var j8, F0, m0; var d0 = z(() => { j8 = ($, ...Q) => { if (!($ instanceof Uint8Array)) throw new Error("Expected Uint8Array"); if (Q.length > 0 && !Q.includes($.length)) throw new Error(`Expected Uint8Array of length ${Q}, not of length=${$.length}`) }, F0 = ($, Q = !0) => { if ($.destroyed) throw new Error("Hash instance has been destroyed"); if (Q && $.finished) throw new Error("Hash#digest() has already been called") }, m0 = ($, Q) => { j8($); const J = Q.outputLen; if ($.length < J) throw new Error(`digestInto() expects output buffer of length at least ${J}`) } }); var u0, W8, b8, o, D0, z8, C8, w8, L8, E8, H8, f8, B8, A8, P8, _8, S8, y8, x8, v8, g8, c8, m8, d8, u8, F; var p0 = z(() => { u0 = ($, Q = !1) => { if (Q) return { h: Number($ & o), l: Number($ >> D0 & o) }; return { h: Number($ >> D0 & o) | 0, l: Number($ & o) | 0 } }, W8 = ($, Q = !1) => { const J = new Uint32Array($.length), q = new Uint32Array($.length); for (let N = 0; N < $.length; N++) { const { h: X, l: Y } = u0($[N], Q);[J[N], q[N]] = [X, Y] } return [J, q] }, b8 = ($, Q, J, q) => { const N = (Q >>> 0) + (q >>> 0); return { h: $ + J + (N / 4294967296 | 0) | 0, l: N | 0 } }, o = BigInt(4294967295), D0 = BigInt(32), z8 = ($, Q) => BigInt($ >>> 0) << D0 | BigInt(Q >>> 0), C8 = ($, Q, J) => $ >>> J, w8 = ($, Q, J) => $ << 32 - J | Q >>> J, L8 = ($, Q, J) => $ >>> J | Q << 32 - J, E8 = ($, Q, J) => $ << 32 - J | Q >>> J, H8 = ($, Q, J) => $ << 64 - J | Q >>> J - 32, f8 = ($, Q, J) => $ >>> J - 32 | Q << 64 - J, B8 = ($, Q) => Q, A8 = ($, Q) => $, P8 = ($, Q, J) => $ << J | Q >>> 32 - J, _8 = ($, Q, J) => Q << J | $ >>> 32 - J, S8 = ($, Q, J) => Q << J - 32 | $ >>> 64 - J, y8 = ($, Q, J) => $ << J - 32 | Q >>> 64 - J, x8 = ($, Q, J) => ($ >>> 0) + (Q >>> 0) + (J >>> 0), v8 = ($, Q, J, q) => Q + J + q + ($ / 4294967296 | 0) | 0, g8 = ($, Q, J, q) => ($ >>> 0) + (Q >>> 0) + (J >>> 0) + (q >>> 0), c8 = ($, Q, J, q, N) => Q + J + q + N + ($ / 4294967296 | 0) | 0, m8 = ($, Q, J, q, N) => ($ >>> 0) + (Q >>> 0) + (J >>> 0) + (q >>> 0) + (N >>> 0), d8 = ($, Q, J, q, N, X) => Q + J + q + N + X + ($ / 4294967296 | 0) | 0, u8 = { fromBig: u0, split: W8, toBig: z8, shrSH: C8, shrSL: w8, rotrSH: L8, rotrSL: E8, rotrBH: H8, rotrBL: f8, rotr32H: B8, rotr32L: A8, rotlSH: P8, rotlSL: _8, rotlBH: S8, rotlBL: y8, add: b8, add3L: x8, add3H: v8, add4L: g8, add4H: c8, add5H: d8, add5L: m8 }, F = u8 }); function i8($) { if (typeof $ !== "string") throw new Error(`utf8ToBytes expected string, got ${typeof $}`); return new Uint8Array((new TextEncoder()).encode($)) } function U0($) { if (typeof $ === "string") $ = i8($); if (!p8($)) throw new Error(`expected Uint8Array, got ${typeof $}`); return $ } function n0($) { const Q = (q) => $().update(U0(q)).digest(), J = $(); return Q.outputLen = J.outputLen, Q.blockLen = J.blockLen, Q.create = () => $(), Q } class k0 { clone() { return this._cloneInto() } } var p8, a, n8, x$; var M0 = z(() => {/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */p8 = ($) => $ instanceof Uint8Array, a = ($) => new DataView($.buffer, $.byteOffset, $.byteLength), n8 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68; if (!n8) throw new Error("Non little-endian hardware is not supported"); x$ = {}.toString }); class O0 extends k0 { constructor($, Q, J, q) { super(); this.blockLen = $, this.outputLen = Q, this.padOffset = J, this.isLE = q, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array($), this.view = a(this.buffer) } update($) { F0(this); const { view: Q, buffer: J, blockLen: q } = this; $ = U0($); const N = $.length; for (let X = 0; X < N;) { const Y = Math.min(q - this.pos, N - X); if (Y === q) { const Z = a($); for (; q <= N - X; X += q)this.process(Z, X); continue } if (J.set($.subarray(X, X + Y), this.pos), this.pos += Y, X += Y, this.pos === q) this.process(Q, 0), this.pos = 0 } return this.length += $.length, this.roundClean(), this } digestInto($) { F0(this), m0($, this), this.finished = !0; const { buffer: Q, view: J, blockLen: q, isLE: N } = this; let { pos: X } = this; if (Q[X++] = 128, this.buffer.subarray(X).fill(0), this.padOffset > q - X) this.process(J, 0), X = 0; for (let I = X; I < q; I++)Q[I] = 0; l8(J, q - 8, BigInt(this.length * 8), N), this.process(J, 0); const Y = a($), Z = this.outputLen; if (Z % 4) throw new Error("_sha2: outputLen should be aligned to 32bit"); const T = Z / 4, U = this.get(); if (T > U.length) throw new Error("_sha2: outputLen bigger than state"); for (let I = 0; I < T; I++)Y.setUint32(4 * I, U[I], N) } digest() { const { buffer: $, outputLen: Q } = this; this.digestInto($); const J = $.slice(0, Q); return this.destroy(), J } _cloneInto($) { $ || ($ = new this.constructor), $.set(...this.get()); const { blockLen: Q, buffer: J, length: q, finished: N, destroyed: X, pos: Y } = this; if ($.length = q, $.pos = Y, $.finished = N, $.destroyed = X, q % Q) $.buffer.set(J); return $ } } var l8; var i0 = z(() => { d0(); M0(); l8 = ($, Q, J, q) => { if (typeof $.setBigUint64 === "function") return $.setBigUint64(Q, J, q); const N = BigInt(32), X = BigInt(4294967295), Y = Number(J >> N & X), Z = Number(J & X), T = q ? 4 : 0, U = q ? 0 : 4; $.setUint32(Q + T, Y, q), $.setUint32(Q + U, Z, q) } }); c0(); function s($) { return $.message !== void 0 } var h8 = 1, r8 = 2; class t { t; n; key_label; metadata; constructor({ t: $, n: Q, key_label: J, permissions: q, ephPK: N }) { if (this.t = $, this.n = Q, this.key_label = J, this.metadata = [], q) this.metadata.push({ tag: h8, value: q }); if (N) this.metadata.push({ tag: r8, value: N }) } } class l0 { authModule; threshold; totalNodes; wp_client; constructor($, Q, J, q) { if (Q === 0) throw new Error("Threshold cannot be 0"); this.threshold = Q, this.totalNodes = J, this.authModule = q, this.wp_client = $ } async authenticateAndCreateKey($, Q) { try { const J = new t({ t: this.threshold, n: this.totalNodes, permissions: Q, ephPK: _($) }); console.log("Generated Payload:", J); const q = (X) => this.authModule.authenticate({ setup: J, challenge: X }), N = await this.wp_client.startKeygen({ setup: J, signer: q }); return console.log("Keygen response:", N), N } catch (J) { throw console.error(J), J } } async authenticateAndSign($, Q) { const J = { t: this.threshold, key_id: $, message: Q }, q = (X) => this.authModule.authenticate({ setup: J, challenge: X }), N = await this.wp_client.startSigngen({ setup: J, signer: q }); return console.log("Sign response:", N), N } } var $$ = ($, Q) => { if ($) return z0(Q.hashable).then(Q.finish); return Q.finish(J8(Q.hashable)) };/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */var j = 2n ** 255n - 19n, x = 2n ** 252n + 27742317777372353535851937790883648493n, R0 = 0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51an, G0 = 0x6666666666666666666666666666666666666666666666666666666666666658n, e = { a: -1n, d: 37095705934669439343138083508754565189542113879843219016388785533085940283555n, p: j, n: x, h: 8, Gx: R0, Gy: G0 }, W = ($ = "") => { throw new Error($) }, t0 = ($) => typeof $ === "string", o8 = ($) => $ instanceof Uint8Array || $ != null && typeof $ === "object" && $.constructor.name === "Uint8Array", p = ($, Q) => !o8($) || typeof Q === "number" && Q > 0 && $.length !== Q ? W("Uint8Array of valid length expected") : $, v = ($) => new Uint8Array($), Q0 = ($, Q) => p(t0($) ? W0($) : v(p($)), Q), V = ($, Q = j) => { const J = $ % Q; return J >= 0n ? J : Q + J }, h0 = ($) => $ instanceof w ? $ : W("Point expected"); class w { constructor($, Q, J, q) { this.ex = $, this.ey = Q, this.ez = J, this.et = q } static fromAffine($) { return new w($.x, $.y, 1n, V($.x * $.y)) } static fromHex($, Q = !1) { const { d: J } = e; $ = Q0($, 32); const q = $.slice(), N = $[31]; q[31] = N & ~128; const X = $8(q); if (Q && !(0n <= X && X < 2n ** 256n)) W("bad y coord 1"); if (!Q && !(0n <= X && X < j)) W("bad y coord 2"); const Y = V(X * X), Z = V(Y - 1n), T = V(J * Y + 1n); let { isValid: U, value: I } = t8(Z, T); if (!U) W("bad y coordinate 3"); const D = (I & 1n) === 1n, k = (N & 128) !== 0; if (!Q && I === 0n && k) W("bad y coord 3"); if (k !== D) I = V(-I); return new w(I, X, 1n, V(I * X)) } get x() { return this.toAffine().x } get y() { return this.toAffine().y } equals($) { const { ex: Q, ey: J, ez: q } = this, { ex: N, ey: X, ez: Y } = h0($), Z = V(Q * Y), T = V(N * q), U = V(J * Y), I = V(X * q); return Z === T && U === I } is0() { return this.equals(d) } negate() { return new w(V(-this.ex), this.ey, this.ez, V(-this.et)) } double() { const { ex: $, ey: Q, ez: J } = this, { a: q } = e, N = V($ * $), X = V(Q * Q), Y = V(2n * V(J * J)), Z = V(q * N), T = $ + Q, U = V(V(T * T) - N - X), I = Z + X, D = I - Y, k = Z - X, R = V(U * D), G = V(I * k), K = V(U * k), C = V(D * I); return new w(R, G, C, K) } add($) { const { ex: Q, ey: J, ez: q, et: N } = this, { ex: X, ey: Y, ez: Z, et: T } = h0($), { a: U, d: I } = e, D = V(Q * X), k = V(J * Y), R = V(N * I * T), G = V(q * Z), K = V((Q + J) * (X + Y) - D - k), C = V(G - R), A = V(G + R), M = V(k - U * D), L = V(K * C), E = V(A * M), c = V(K * M), m = V(C * A); return new w(L, E, m, c) } mul($, Q = !0) { if ($ === 0n) return Q === !0 ? W("cannot multiply by 0") : d; if (!(typeof $ === "bigint" && 0n < $ && $ < x)) W("invalid scalar, must be < L"); if (!Q && this.is0() || $ === 1n) return this; if (this.equals(g)) return q$($).p; let J = d, q = g; for (let N = this; $ > 0n; N = N.double(), $ >>= 1n)if ($ & 1n) J = J.add(N); else if (Q) q = q.add(N); return J } multiply($) { return this.mul($) } clearCofactor() { return this.mul(BigInt(e.h), !1) } isSmallOrder() { return this.clearCofactor().is0() } isTorsionFree() { let $ = this.mul(x / 2n, !1).double(); if (x % 2n) $ = $.add(this); return $.is0() } toAffine() { const { ex: $, ey: Q, ez: J } = this; if (this.equals(d)) return { x: 0n, y: 1n }; const q = Q8(J); if (V(J * q) !== 1n) W("invalid inverse"); return { x: V($ * q), y: V(Q * q) } } toRawBytes() { const { x: $, y: Q } = this.toAffine(), J = e0(Q); return J[31] |= $ & 1n ? 128 : 0, J } toHex() { return j0(this.toRawBytes()) } } w.BASE = new w(R0, G0, 1n, V(R0 * G0)); w.ZERO = new w(0n, 1n, 1n, 0n); var { BASE: g, ZERO: d } = w, s0 = ($, Q) => $.toString(16).padStart(Q, "0"), j0 = ($) => Array.from($).map((Q) => s0(Q, 2)).join(""), W0 = ($) => { const Q = $.length; if (!t0($) || Q % 2) W("hex invalid 1"); const J = v(Q / 2); for (let q = 0; q < J.length; q++) { const N = q * 2, X = $.slice(N, N + 2), Y = Number.parseInt(X, 16); if (Number.isNaN(Y) || Y < 0) W("hex invalid 2"); J[q] = Y } return J }, e0 = ($) => W0(s0($, 64)).reverse(), $8 = ($) => BigInt("0x" + j0(v(p($)).reverse())), $0 = (...$) => { const Q = v($.reduce((q, N) => q + p(N).length, 0)); let J = 0; return $.forEach((q) => { Q.set(q, J), J += q.length }), Q }, Q8 = ($, Q = j) => { if ($ === 0n || Q <= 0n) W("no inverse n=" + $ + " mod=" + Q); let J = V($, Q), q = Q, N = 0n, X = 1n, Y = 1n, Z = 0n; while (J !== 0n) { const T = q / J, U = q % J, I = N - Y * T, D = X - Z * T; q = J, J = U, N = Y, X = Z, Y = I, Z = D } return q === 1n ? V(N, Q) : W("no inverse") }, H = ($, Q) => { let J = $; while (Q-- > 0n) J *= J, J %= j; return J }, a8 = ($) => { const J = $ * $ % j * $ % j, q = H(J, 2n) * J % j, N = H(q, 1n) * $ % j, X = H(N, 5n) * N % j, Y = H(X, 10n) * X % j, Z = H(Y, 20n) * Y % j, T = H(Z, 40n) * Z % j, U = H(T, 80n) * T % j, I = H(U, 80n) * T % j, D = H(I, 10n) * X % j; return { pow_p_5_8: H(D, 2n) * $ % j, b2: J } }, r0 = 19681161376707505956807079304988542015446066515923890162744021073123829784752n, t8 = ($, Q) => { const J = V(Q * Q * Q), q = V(J * J * Q), N = a8($ * q).pow_p_5_8; let X = V($ * J * N); const Y = V(Q * X * X), Z = X, T = V(X * r0), U = Y === $, I = Y === V(-$), D = Y === V(-$ * r0); if (U) X = Z; if (I || D) X = T; if ((V(X) & 1n) === 1n) X = V(-X); return { isValid: U || I, value: X } }, K0 = ($) => V($8($), x), u, z0 = (...$) => n.sha512Async(...$), J8 = (...$) => typeof u === "function" ? u(...$) : W("etc.sha512Sync not set"), q8 = ($) => { const Q = $.slice(0, 32); Q[0] &= 248, Q[31] &= 127, Q[31] |= 64; const J = $.slice(32, 64), q = K0(Q), N = g.mul(q), X = N.toRawBytes(); return { head: Q, prefix: J, scalar: q, point: N, pointBytes: X } }, s8 = ($) => z0(Q0($, 32)).then(q8), e8 = ($) => q8(J8(Q0($, 32))); var N8 = ($) => e8($).pointBytes, Q$ = ($, Q, J) => { const { pointBytes: q, scalar: N } = $, X = K0(Q), Y = g.mul(X).toRawBytes(); return { hashable: $0(Y, q, J), finish: (U) => { const I = V(X + K0(U) * N, x); return p($0(Y, e0(I)), 64) } } }, X8 = async ($, Q) => { const J = Q0($), q = await s8(Q), N = await z0(q.prefix, J); return $$(!0, Q$(q, N, J)) }; var o0 = () => typeof globalThis === "object" && ("crypto" in globalThis) ? globalThis.crypto : void 0, n = { bytesToHex: j0, hexToBytes: W0, concatBytes: $0, mod: V, invert: Q8, randomBytes: ($ = 32) => { const Q = o0(); if (!Q || !Q.getRandomValues) W("crypto.getRandomValues must be defined"); return Q.getRandomValues(v($)) }, sha512Async: async (...$) => { const Q = o0(); if (!Q || !Q.subtle) W("crypto.subtle or etc.sha512Async must be defined"); const J = $0(...$); return v(await Q.subtle.digest("SHA-512", J.buffer)) }, sha512Sync: void 0 }; Object.defineProperties(n, { sha512Sync: { configurable: !1, get() { return u }, set($) { if (!u) u = $ } } }); var b = 8, J$ = () => { const $ = [], Q = 256 / b + 1; let J = g, q = J; for (let N = 0; N < Q; N++) { q = J, $.push(q); for (let X = 1; X < 2 ** (b - 1); X++)q = q.add(J), $.push(q); J = q.double() } return $ }, a0 = void 0, q$ = ($) => { const Q = a0 || (a0 = J$()), J = (I, D) => { const k = D.negate(); return I ? k : D }; let q = d, N = g; const X = 1 + 256 / b, Y = 2 ** (b - 1), Z = BigInt(2 ** b - 1), T = 2 ** b, U = BigInt(b); for (let I = 0; I < X; I++) { const D = I * Y; let k = Number($ & Z); if ($ >>= U, k > Y) k -= T, $ += 1n; const R = D, G = D + Math.abs(k) - 1, K = I % 2 !== 0, C = k < 0; if (k === 0) N = N.add(J(K, Q[R])); else q = q.add(J(C, Q[G])) } return { p: q, f: N } }; i0(); p0(); M0(); var [N$, X$] = (() => F.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(($) => BigInt($))))(), S = new Uint32Array(80), y = new Uint32Array(80); class Z8 extends O0 { constructor() { super(128, 64, 16, !1); this.Ah = 1779033703 | 0, this.Al = 4089235720 | 0, this.Bh = 3144134277 | 0, this.Bl = 2227873595 | 0, this.Ch = 1013904242 | 0, this.Cl = 4271175723 | 0, this.Dh = 2773480762 | 0, this.Dl = 1595750129 | 0, this.Eh = 1359893119 | 0, this.El = 2917565137 | 0, this.Fh = 2600822924 | 0, this.Fl = 725511199 | 0, this.Gh = 528734635 | 0, this.Gl = 4215389547 | 0, this.Hh = 1541459225 | 0, this.Hl = 327033209 | 0 } get() { const { Ah: $, Al: Q, Bh: J, Bl: q, Ch: N, Cl: X, Dh: Y, Dl: Z, Eh: T, El: U, Fh: I, Fl: D, Gh: k, Gl: R, Hh: G, Hl: K } = this; return [$, Q, J, q, N, X, Y, Z, T, U, I, D, k, R, G, K] } set($, Q, J, q, N, X, Y, Z, T, U, I, D, k, R, G, K) { this.Ah = $ | 0, this.Al = Q | 0, this.Bh = J | 0, this.Bl = q | 0, this.Ch = N | 0, this.Cl = X | 0, this.Dh = Y | 0, this.Dl = Z | 0, this.Eh = T | 0, this.El = U | 0, this.Fh = I | 0, this.Fl = D | 0, this.Gh = k | 0, this.Gl = R | 0, this.Hh = G | 0, this.Hl = K | 0 } process($, Q) { for (let M = 0; M < 16; M++, Q += 4)S[M] = $.getUint32(Q), y[M] = $.getUint32(Q += 4); for (let M = 16; M < 80; M++) { const L = S[M - 15] | 0, E = y[M - 15] | 0, c = F.rotrSH(L, E, 1) ^ F.rotrSH(L, E, 8) ^ F.shrSH(L, E, 7), m = F.rotrSL(L, E, 1) ^ F.rotrSL(L, E, 8) ^ F.shrSL(L, E, 7), f = S[M - 2] | 0, B = y[M - 2] | 0, i = F.rotrSH(f, B, 19) ^ F.rotrBH(f, B, 61) ^ F.shrSH(f, B, 6), J0 = F.rotrSL(f, B, 19) ^ F.rotrBL(f, B, 61) ^ F.shrSL(f, B, 6), l = F.add4L(m, J0, y[M - 7], y[M - 16]), q0 = F.add4H(l, c, i, S[M - 7], S[M - 16]); S[M] = q0 | 0, y[M] = l | 0 } let { Ah: J, Al: q, Bh: N, Bl: X, Ch: Y, Cl: Z, Dh: T, Dl: U, Eh: I, El: D, Fh: k, Fl: R, Gh: G, Gl: K, Hh: C, Hl: A } = this; for (let M = 0; M < 80; M++) { const L = F.rotrSH(I, D, 14) ^ F.rotrSH(I, D, 18) ^ F.rotrBH(I, D, 41), E = F.rotrSL(I, D, 14) ^ F.rotrSL(I, D, 18) ^ F.rotrBL(I, D, 41), c = I & k ^ ~I & G, m = D & R ^ ~D & K, f = F.add5L(A, E, m, X$[M], y[M]), B = F.add5H(f, C, L, c, N$[M], S[M]), i = f | 0, J0 = F.rotrSH(J, q, 28) ^ F.rotrBH(J, q, 34) ^ F.rotrBH(J, q, 39), l = F.rotrSL(J, q, 28) ^ F.rotrBL(J, q, 34) ^ F.rotrBL(J, q, 39), q0 = J & N ^ J & Y ^ N & Y, M8 = q & X ^ q & Z ^ X & Z; C = G | 0, A = K | 0, G = k | 0, K = R | 0, k = I | 0, R = D | 0, { h: I, l: D } = F.add(T | 0, U | 0, B | 0, i | 0), T = Y | 0, U = Z | 0, Y = N | 0, Z = X | 0, N = J | 0, X = q | 0; const w0 = F.add3L(i, l, M8); J = F.add3H(w0, B, J0, q0), q = w0 | 0 } ({ h: J, l: q } = F.add(this.Ah | 0, this.Al | 0, J | 0, q | 0)), { h: N, l: X } = F.add(this.Bh | 0, this.Bl | 0, N | 0, X | 0), { h: Y, l: Z } = F.add(this.Ch | 0, this.Cl | 0, Y | 0, Z | 0), { h: T, l: U } = F.add(this.Dh | 0, this.Dl | 0, T | 0, U | 0), { h: I, l: D } = F.add(this.Eh | 0, this.El | 0, I | 0, D | 0), { h: k, l: R } = F.add(this.Fh | 0, this.Fl | 0, k | 0, R | 0), { h: G, l: K } = F.add(this.Gh | 0, this.Gl | 0, G | 0, K | 0), { h: C, l: A } = F.add(this.Hh | 0, this.Hl | 0, C | 0, A | 0), this.set(J, q, N, X, Y, Z, T, U, I, D, k, R, G, K, C, A) } roundClean() { S.fill(0), y.fill(0) } destroy() { this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) } } var I8 = n0(() => new Z8); var T$ = ($, Q, J) => { console.log("EPHKEY", J); const q = new t({ t: $.t, n: $.n, key_label: $.key_label, permissions: void 0, ephPK: _(J) }); return console.log("SETUP_NO_PERM", q), { types: { EIP712Domain: V$, ...Z$ }, domain: I$, primaryType: "Request", message: { setup: q, challenge: Q } } }; async function V8({ setup: $, user_id: Q, challenge: J, browserWallet: q, ephPK: N, lifetime: X }) { if (s($)) throw new Error("EOA auth cannot be used for Sign requests, please use EphAuth instead"); const Y = T$($, J, N); console.log("typed request:"), console.log(JSON.stringify(Y, void 0, 4)); const Z = await q.signTypedData(Q, Y); console.log("User signed a request", Z); const T = { eoa: Q, ephPK: _(N), expiry: Math.floor(Date.now() / 1000) + X }; return { credentials: { credentials: JSON.stringify(T), method: "eoa", id: Q }, signature: Z } } async function T8({ setup: $, user_id: Q, challenge: J, ephSK: q, ephPK: N }) { const X = { setup: $, challenge: J }, Z = _(await X8((new TextEncoder()).encode(JSON.stringify(X)), q)); console.log("AUTH SIGNATURE by eph key", Z), console.log("User signed a request", Z); const T = { eoa: Q, ephPK: _(N), expiry: 0 }; return { credentials: { credentials: JSON.stringify(T), method: "ephemeral", id: Q }, signature: Z } } n.sha512Sync = (...$) => I8(n.concatBytes(...$)); var Y$ = [{ name: "tag", type: "uint16" }, { name: "value", type: "string" }], Z$ = { Request: [{ name: "setup", type: "KeygenSetupOpts" }, { name: "challenge", type: "string" }], KeygenSetupOpts: [{ name: "t", type: "uint32" }, { name: "n", type: "uint32" }, { name: "metadata", type: "TaggedValue[]" }], TaggedValue: Y$ }, I$ = { name: "SilentShard authentication", version: "0.1.0" }, V$ = [{ name: "name", type: "string" }, { name: "version", type: "string" }]; var C0; ((J) => { J[J["EOA"] = 0] = "EOA"; J[J["NONE"] = 1] = "NONE" })(C0 || (C0 = {})); class F8 { userId; browserWallet; ephPK; lifetime; constructor($, Q, J, q = 3600) { this.userId = $, this.browserWallet = Q, this.ephPK = J, this.lifetime = q } async authenticate({ setup: $, challenge: Q }) { return await V8({ setup: $, user_id: this.userId, challenge: Q, browserWallet: this.browserWallet, ephPK: this.ephPK, lifetime: this.lifetime }) } } class D8 { userId; ephSK; ephPK; constructor($, Q) { this.userId = $, this.ephSK = Q, this.ephPK = N8(this.ephSK) } async authenticate({ setup: $, challenge: Q }) { return await T8({ setup: $, user_id: this.userId, challenge: Q, ephSK: this.ephSK, ephPK: this.ephPK }) } } var U8 = ($) => btoa(String.fromCodePoint.apply(null, Array.from($))); var O; ((N) => { N[N["initiated"] = 0] = "initiated"; N[N["waitingForSign"] = 1] = "waitingForSign"; N[N["waitingForResult"] = 2] = "waitingForResult"; N[N["finished"] = 3] = "finished" })(O || (O = {})); class k8 { walletProviderId; walletProviderUrl; constructor($) { this.walletProviderId = $.walletProviderId, this.walletProviderUrl = $.walletProviderUrl } getWalletId() { return this.walletProviderId } async startKeygen({ setup: $, signer: Q }) { return this.connect($, Q).then((J) => { const q = J.split(":"), N = q[1].split("=")[1], X = q[0].split("=")[1]; return { publicKey: N, keyId: X } }) } async startSigngen({ setup: $, signer: Q }) { return this.connect($, Q).then((J) => { const q = J.split(":"), N = q[0].split("=")[1], X = q[1].split("=")[1]; return { sign: N, recid: Number.parseInt(X) } }) } connect($, Q) { return new Promise((J, q) => { let N = O.initiated, X; if (s($)) X = "signgen", $.message = U8((new TextEncoder()).encode($.message)); else X = "keygen"; const Y = new WebSocket(`${this.walletProviderUrl}/${X}`); Y.addEventListener("open", (Z) => { switch (console.log(`Connection opened in state ${N} with event ${JSON.stringify(Z, void 0, "\t")}`), N) { case O.initiated: N = O.waitingForSign, console.log(`Sending setup: ${JSON.stringify($)}`), Y.send(JSON.stringify($)); break; case O.waitingForSign: case O.waitingForResult: N = O.finished, q("Incorrect protocol state"); break; case O.finished: break } }), Y.addEventListener("message", async (Z) => { switch (console.log(`Connection message in state ${N} with event ${JSON.stringify(Z, void 0, "\t")}`), N) { case O.initiated: N = O.finished, q("Incorrect protocol state"); break; case O.waitingForSign: { N = O.waitingForResult; const T = await Q(Z.data); console.log(`Sending signature: ${JSON.stringify(T)}`), Y.send(JSON.stringify(T)); break } case O.waitingForResult: N = O.finished, Y.close(), J(Z.data); break; case O.finished: break } }), Y.addEventListener("error", (Z) => { if (console.log(`Connection error in state ${N} with event ${JSON.stringify(Z, void 0, "\t")}`), N != O.finished) N = O.finished, q("Incorrect protocol state") }), Y.addEventListener("close", (Z) => { if (console.log(`Connection closed in state ${N} with event ${JSON.stringify(Z, void 0, "\t")}`), N != O.finished) N = O.finished, q("Incorrect protocol state") }) }) } } export { k8 as WalletProviderServiceClient, l0 as NetworkSigner, D8 as EphAuth, F8 as EOAAuth, C0 as AuthMethod };
