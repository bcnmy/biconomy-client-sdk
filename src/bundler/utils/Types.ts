import { type Address, type Chain, type Hash, type Hex, toHex } from "viem"
import type { PartialBy } from "viem/chains"
import type {
  ENTRYPOINT_ADDRESS_V07_TYPE,
  UserOperationStruct
} from "../../accounts"

export type Bundlerconfig = {
  bundlerUrl: string
  entryPointAddress?: string
  chainId?: number
  // eslint-disable-next-line no-unused-vars
  userOpReceiptIntervals?: { [key in number]?: number }
  userOpWaitForTxHashIntervals?: { [key in number]?: number }
  userOpReceiptMaxDurationIntervals?: { [key in number]?: number }
  userOpWaitForTxHashMaxDurationIntervals?: { [key in number]?: number }
  /** Can be used to optionally override the chain with a custom chain if it doesn't already exist in viems list of supported chains */
  viemChain?: Chain
}
export type BundlerConfigWithChainId = Bundlerconfig & { chainId: number }

export type UserOpReceipt = {
  /* The request hash of the UserOperation. */
  userOpHash: string
  /* The entry point address used for the UserOperation. */
  entryPoint: string
  /* The paymaster used for this UserOperation (or empty). */
  paymaster: string
  /* The actual amount paid (by account or paymaster) for this UserOperation. */
  actualGasCost: Hex
  /* The total gas used by this UserOperation (including preVerification, creation, validation, and execution). */
  actualGasUsed: Hex
  /* Indicates whether the execution completed without reverting. */
  success: "true" | "false"
  /* In case of revert, this is the revert reason. */
  reason: string
  /* The logs generated by this UserOperation (not including logs of other UserOperations in the same bundle). */
  logs: Array<any> // The logs generated by this UserOperation (not including logs of other UserOperations in the same bundle)
  /* The TransactionReceipt object for the entire bundle, not only for this UserOperation. */
  receipt: any
}

// review
export type UserOpStatus = {
  state: string // for now // could be an enum
  transactionHash?: string
  userOperationReceipt?: UserOpReceipt
}

// Converted to JsonRpcResponse with strict type
export type GetUserOperationReceiptResponse = {
  jsonrpc: string
  id: number
  result: UserOpReceipt
  error?: JsonRpcError
}

export type GetUserOperationStatusResponse = {
  jsonrpc: string
  id: number
  result: UserOpStatus
  error?: JsonRpcError
}

// Converted to JsonRpcResponse with strict type
export type SendUserOpResponse = {
  jsonrpc: string
  id: number
  result: string
  error?: JsonRpcError
}

export type UserOpResponse = {
  userOpHash: string
  wait(_confirmations?: number): Promise<UserOpReceipt>
  // Review: waitForTxHash(): vs waitForTxHash?():
  waitForTxHash(): Promise<UserOpStatus>
}

// Converted to JsonRpcResponse with strict type
export type EstimateUserOpGasResponse = {
  jsonrpc: string
  id: number
  result: UserOpGasResponse
  error?: JsonRpcError
}

export type UserOpGasResponse = {
  preVerificationGas: string
  verificationGasLimit: string
  callGasLimit: string
  maxPriorityFeePerGas: string
  maxFeePerGas: string
}

// Converted to JsonRpcResponse with strict type
export type GetUserOpByHashResponse = {
  jsonrpc: string
  id: number
  result: UserOpByHashResponse
  error?: JsonRpcError
}

export type UserOpByHashResponse = UserOperationStruct & {
  transactionHash: string
  blockNumber: number
  blockHash: string
  entryPoint: string
}
/* eslint-disable  @typescript-eslint/no-explicit-any */
export type JsonRpcError = {
  code: string
  message: string
  data: any
}

export type GetGasFeeValuesResponse = {
  jsonrpc: string
  id: number
  result: GasFeeValues
  error?: JsonRpcError
}
export type GasFeeValues = {
  maxPriorityFeePerGas: string
  maxFeePerGas: string
}

export type BundlerRpcSchema = [
  {
    Method: "eth_sendUserOperation"
    Parameters: [
      userOperation: UserOperationStruct,
      entryPoint: ENTRYPOINT_ADDRESS_V07_TYPE
    ]
    ReturnType: Hash
  },
  {
    Method: "eth_estimateUserOperationGas"
    Parameters: [
      userOperation: PartialBy<
        UserOperationStruct,
        | "callGasLimit"
        | "preVerificationGas"
        | "verificationGasLimit"
        | "paymasterVerificationGasLimit"
        | "paymasterPostOpGasLimit"
      >,
      entryPoint: ENTRYPOINT_ADDRESS_V07_TYPE,
      stateOverrides?: StateOverrides
    ]
    ReturnType: {
      preVerificationGas: Hex
      verificationGasLimit: Hex
      callGasLimit?: Hex | null
      paymasterVerificationGasLimit?: Hex | null
      paymasterPostOpGasLimit?: Hex | null
    }
  },
  {
    Method: "eth_supportedEntryPoints"
    Parameters: []
    ReturnType: Address[]
  },
  {
    Method: "eth_chainId"
    Parameters: []
    ReturnType: Hex
  },
  {
    Method: "eth_getUserOperationByHash"
    Parameters: [userOpHash: Hash]
    ReturnType: {
      transactionHash: Hash
      blockNumber: Hex
      blockHash: Hash
      entryPoint: ENTRYPOINT_ADDRESS_V07_TYPE
    }
  },
  {
    Method: "eth_getUserOperationReceipt"
    Parameters: [hash: Hash]
    ReturnType: UserOperationReceiptWithBigIntAsHex
  },
  {
    Method: "biconomy_getGasFeeValues"
    Parameters: []
    ReturnType: {
      maxPriorityFeePerGas: Hex
      maxFeePerGas: Hex
    }
  },
  {
    Method: "biconomy_getUserOperationStatus"
    Parameters: [hash: Hash]
    ReturnType: UserOpStatus
  }
]

type UserOperationReceiptWithBigIntAsHex = {
  userOpHash: Hash
  entryPoint: Address
  sender: Address
  nonce: Hex
  paymaster?: Address
  actualGasUsed: Hex
  actualGasCost: Hex
  success: "true" | "false"
  reason?: string
  receipt: {
    transactionHash: Hex
    transactionIndex: Hex
    blockHash: Hash
    blockNumber: Hex
    from: Address
    to: Address | null
    cumulativeGasUsed: Hex
    status: "0x0" | "0x1"
    gasUsed: Hex
    contractAddress: Address | null
    logsBloom: Hex
    effectiveGasPrice: Hex
  }
  logs: {
    data: Hex
    blockNumber: Hex
    blockHash: Hash
    transactionHash: Hash
    logIndex: Hex
    transactionIndex: Hex
    address: Address
    topics: [Hex, ...Hex[]] | []
    removed: boolean
  }[]
}

export type StateOverrides = {
  [x: string]: {
    balance?: bigint | undefined
    nonce?: bigint | number | undefined
    code?: Hex | undefined
    state?: {
      [x: Hex]: Hex
    }
    stateDiff?: {
      [x: Hex]: Hex
    }
  }
}

export function deepHexlify(obj: any): any {
  if (typeof obj === "function") {
    return undefined
  }
  if (obj == null || typeof obj === "string" || typeof obj === "boolean") {
    return obj
  }

  if (typeof obj === "bigint") {
    return toHex(obj)
  }

  if (obj._isBigNumber != null || typeof obj !== "object") {
    return toHex(obj).replace(/^0x0/, "0x")
  }
  if (Array.isArray(obj)) {
    return obj.map((member) => deepHexlify(member))
  }
  return Object.keys(obj).reduce(
    // biome-ignore lint/suspicious/noExplicitAny: it's a recursive function, so it's hard to type
    (set: any, key: string) => {
      set[key] = deepHexlify(obj[key])
      return set
    },
    {}
  )
}
